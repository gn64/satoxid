use std::{fmt::{self, Debug}, iter::once, ops::{BitAnd, BitOr, Neg}};

use crate::{Constraint, Encoder, Lit, SatVar, VarMap, clause};

use super::util::ClauseCollector;

/// Tseitin Encoding of propositional logic formulas.
#[derive(Clone)]
pub enum Expr<V> {
    And(Box<Expr<V>>, Box<Expr<V>>),
    Or(Box<Expr<V>>, Box<Expr<V>>),
    Neg(Box<Expr<V>>),
    Lit(Lit<V>),
    Constraint(ExprConstraint<V>),
}

impl<V: Debug> Debug for Expr<V> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Expr::And(lhs, rhs) => f.debug_tuple("And").field(&lhs).field(&rhs).finish(),
            Expr::Or(lhs, rhs) => f.debug_tuple("Or").field(&lhs).field(&rhs).finish(),
            Expr::Neg(e) => f.debug_tuple("Neg").field(&e).finish(),
            Expr::Lit(lit) => f.debug_tuple("Lit").field(&lit).finish(),
            Expr::Constraint(constraint) => {
                f.debug_tuple("Constraint").field(&constraint.0).finish()
            }
        }
    }
}

pub struct ExprConstraint<V>(Box<dyn DynConstraint<V>>);

impl<V> Clone for ExprConstraint<V> {
    fn clone(&self) -> Self {
        Self(self.0.dyn_clone())
    }
}

impl<V: SatVar> Debug for ExprConstraint<V> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl<V: SatVar> ExprConstraint<V> {
    fn new<C>(constraint: C) -> Self
    where
        C: Constraint<V> + Clone + 'static,
    {
        Self(Box::new(constraint))
    }
}

impl<V: SatVar> Expr<V> {
    pub fn from_constraint<C>(constraint: C) -> Self
    where
        C: Constraint<V> + Clone + 'static,
    {
        Self::Constraint(ExprConstraint::new(constraint))
    }
}

trait DynConstraint<V>: Debug {
    fn encode(self: Box<Self>, solver: &mut ClauseCollector<V>);

    fn dyn_clone(&self) -> Box<dyn DynConstraint<V>>;
}

impl<C, V> DynConstraint<V> for C
where
    V: SatVar,
    C: Constraint<V> + Clone + 'static,
{
    fn encode(self: Box<Self>, solver: &mut ClauseCollector<V>) {
        let this = *self;
        <Self as Constraint<V>>::encode(this, solver);
    }

    fn dyn_clone(&self) -> Box<dyn DynConstraint<V>> {
        Box::new(<Self as Clone>::clone(self))
    }
}

impl<V: SatVar> Expr<V> {
    fn encode_tree<E: Encoder<V>>(self, solver: &mut E) -> i32 {
        match self {
            Expr::Or(lhs, rhs) => {
                let lhs_var = lhs.encode_tree(solver);
                let rhs_var = rhs.encode_tree(solver);
                let new_var = solver.varmap().new_var();

                solver.add_clause(clause!(-new_var, lhs_var, rhs_var));
                solver.add_clause(clause!(new_var, -lhs_var));
                solver.add_clause(clause!(new_var, -rhs_var));

                new_var
            }
            Expr::And(lhs, rhs) => {
                let lhs_var = lhs.encode_tree(solver);
                let rhs_var = rhs.encode_tree(solver);
                let new_var = solver.varmap().new_var();

                solver.add_clause(clause!(-new_var, lhs_var));
                solver.add_clause(clause!(-new_var, rhs_var));
                solver.add_clause(clause!(-lhs_var, -rhs_var, new_var));

                new_var
            }
            Expr::Neg(e) => {
                let new_var = solver.varmap().new_var();
                let e = e.encode_tree(solver);
                solver.add_clause(clause!(-e, -new_var));
                solver.add_clause(clause!(e, new_var));
                new_var
            }
            Expr::Lit(e) => solver.varmap().add_var(e),
            Expr::Constraint(constraint) => {
                let mut solver_wrapper = ClauseCollector {
                    clauses: Vec::new(),
                    varmap: solver.varmap(),
                };

                constraint.0.encode(&mut solver_wrapper);

                let ClauseCollector { clauses, .. } = solver_wrapper;

                // Every clause generated by constraint gets a representant,
                // which encodes the same logical value.
                let mut clause_repr = Vec::new();

                for clause in clauses {
                    let repr = solver.varmap().new_var();

                    solver.add_clause(clause.iter().copied().chain(once(-repr)));

                    for v in clause {
                        solver.add_clause(clause!(-v, repr));
                    }

                    clause_repr.push(repr);
                }

                // Finally create representant which is true if all clauses are true.
                let and_repr = solver.varmap().new_var();

                solver.add_clause(clause_repr.iter().map(|i| -i).chain(once(and_repr)));

                for repr in clause_repr {
                    solver.add_clause(clause!(-and_repr, repr));
                }

                and_repr
            }
        }
    }
}

impl<V> From<Lit<V>> for Expr<V> {
    fn from(v: Lit<V>) -> Self {
        Self::Lit(v)
    }
}

impl<V, R: Into<Self>> BitAnd<R> for Expr<V> {
    type Output = Expr<V>;

    fn bitand(self, rhs: R) -> Self::Output {
        let rhs = rhs.into();
        Self::And(Box::new(self), Box::new(rhs))
    }
}

impl<V, R: Into<Self>> BitOr<R> for Expr<V> {
    type Output = Expr<V>;

    fn bitor(self, rhs: R) -> Self::Output {
        let rhs = rhs.into();
        Self::Or(Box::new(self), Box::new(rhs))
    }
}

impl<V> Neg for Expr<V> {
    type Output = Self;

    fn neg(self) -> Self::Output {
        Self::Neg(Box::new(self))
    }
}

impl<V: Debug + SatVar> Constraint<V> for Expr<V> {
    fn encode<E: Encoder<V>>(self, solver: &mut E) {
        let v = self.encode_tree(solver);
        solver.add_clause(clause!(v));
    }
}
